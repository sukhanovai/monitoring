/docs/api_202020_project.md
Server Monitoring System v8.3.47
Copyright (c) 2025 Aleksandr Sukhanov
License: MIT
Документ планирования API 202020
Система мониторинга серверов
Версия: 8.3.47
Автор: Александр Суханов (c)
Лицензия: MIT
Документ планирования API 202020

# API 202020 — подробный план первого этапа

## Этап 1. Проектирование BFF-контрактов (2–3 рабочих дня)

Цель этапа: зафиксировать **что именно Android получает от BFF**, **как BFF ходит во внутренние сервисы**, и какие нефункциональные ограничения обязательны (SLO/таймауты/ошибки). На выходе должна быть согласованная база, чтобы дальше в разработке не началась хаотичная переделка контрактов.

---

## 1) Что входит в этап

1. Отбор 5–10 приоритетных Android-сценариев для первой поставки.
2. Проектирование внешнего контракта BFF (REST/gRPC, формат ответов и ошибок).
3. Проектирование внутренних контрактов BFF -> сервисы (proto, idempotency, retries).
4. Фиксация нефункциональных требований (SLO, timeout budget, fallback-стратегии).
5. Подготовка backlog для следующего этапа (каркас + вертикальный срез).

---

## 2) Роли и ответственность

> Дополнительная вводная: проект ведёт один человек, который совмещает все роли ниже и несёт итоговую ответственность за решения и результат.

- **Backend/BFF инженер**: лидер по контрактам BFF, ограничениями по payload и timeout budget.
- **Android инженер**: подтверждает удобство полей/ошибок, требования по версиям API.
- **Сервисные команды (владельцы gRPC сервисов)**: согласуют внутренние proto и SLA.
- **QA/автотесты**: формализуют acceptance-критерии для контрактных тестов.
- **Техлид/архитектор**: финальное решение по спорным кейсам и DoD.

### Как работать в соло-режиме (без потери качества)

Чтобы не скатиться в хаос, один исполнитель последовательно «переключает шапки»:

1. **Продукт + Android взгляд** — сначала фиксируем пользовательскую ценность и минимальный payload.
2. **BFF/backend взгляд** — затем проектируем endpoint, ошибки, ограничения по timeout.
3. **Внутренние сервисы взгляд** — проверяем реалистичность gRPC-контрактов и зависимостей.
4. **QA взгляд** — формулируем проверяемые acceptance-критерии.
5. **Техлид взгляд** — в конце дня делаем self-review и принимаем финальные решения.

Правило: пока не пройден чек-лист текущей «шапки», к следующей не переходим.

---

## 3) Детальный план по дням

### День 1 — сценарии и границы

Ниже — максимально приземлённый план для старта «с минимальным опытом», чтобы ничего не сломать в текущем боте.

#### Перед стартом: 3 правила безопасности (обязательно)

1. **Сегодня не меняем код бота и конфиги прод-окружения.** Работаем только с документацией и черновиками контрактов.
2. **Любое спорное решение помечаем как `Open question`, а не «додумываем».** Это защищает от неправильных реализаций.
3. **Фиксируем изменения маленькими шагами.** После каждого шага сохраняем промежуточный результат в markdown.

---

#### Шаг 0. Подготовить рабочую зону (30–45 минут)

1. Создай/проверь файлы:
   - `docs/contracts/external_bff_api.md`;
   - `docs/contracts/error_mapping.md`;
   - `docs/backlog/stage2_vertical_slice.md`.
2. В каждый файл добавь шапку:
   - `Status: Draft`;
   - `Owner: <твоё имя/ник>`;
   - `Last updated: YYYY-MM-DD`.
3. В этом документе (`docs/api_202020_project.md`) оставь ссылки на эти артефакты.


Ссылки на артефакты Шага 0:
- [External BFF API Draft](./contracts/external_bff_api.md)
- [Error Mapping Draft](./contracts/error_mapping.md)
- [Stage 2 Vertical Slice Backlog Draft](./backlog/stage2_vertical_slice.md)

**Готово, если:** файлы существуют, шапка заполнена, ссылки не битые.

---

#### Шаг 1. Собрать сценарии «как пользователь тыкает приложение» (60–90 минут)

Цель: сначала понять пользовательские действия, а не API.

1. Выпиши 10–15 сценариев в формате «пользователь хочет ... и нажимает ...».
2. Для каждого заполни мини-карточку:
   - `Название`;
   - `Зачем пользователю`;
   - `Где в Android` (экран/кнопка/событие);
   - `Что будет плохо, если сценарий не работает`.
3. Удали дубли (например, «обновить профиль» и «сохранить профиль» — один сценарий).

**Готово, если:** есть единый список сценариев без повторов.

##### Черновик сценариев для текущего бота (заполненный пример)

Ниже — стартовый набор сценариев по текущему меню бота. Это рабочая база для Шага 1, которую можно сразу переносить в таблицу приоритизации (Шаг 2).

| # | Название | Зачем пользователю | Где в Android | Что будет плохо, если сценарий не работает |
|---|---|---|---|---|
| 1 | Доступность серверов | Быстро понять общее состояние инфраструктуры одним действием. | Главный экран -> кнопка пункта меню «Доступность серверов». | Пользователь не видит общую картину и тратит время на проверку каждого сервера вручную. |
| 2 | Доступность сервера | Проверить статус конкретного сервера в моменте. | Главное меню -> «Доступность сервера» -> выбор сервера. | Нельзя точечно подтвердить проблему на конкретном узле. |
| 3 | Ресурсы сервера | Посмотреть CPU/RAM/диск и другие метрики одного сервера. | Главное меню -> «Ресурсы сервера» -> выбор сервера. | Не видно причин деградации; сложнее диагностировать инциденты. |
| 4 | Управление | Перейти к ключевым функциям операционного управления ботом. | Главное меню -> кнопка «Управление». | Пользователь теряет быстрый доступ к основным управляющим действиям. |
| 5 | Приостановление/возобновление мониторинга | Временно выключить/включить основной цикл мониторинга. | Раздел «Управление» -> переключатель мониторинга. | Нельзя безопасно остановить спам алертов при техработах или вернуть мониторинг после них. |
| 6 | Утренний отчет (ручной запуск) | Принудительно получить сводку по логам и расширениям. | Раздел «Управление» -> кнопка «Утренний отчет». | Пользователь не может быстро запросить сводку вне расписания. |
| 7 | Управление тихим режимом | Открыть настройки режима оповещений. | Раздел «Управление» -> «Управление тихим режимом». | Нельзя централизованно контролировать поведение уведомлений. |
| 8 | Включить принудительно тихий режим | Немедленно отключить шумные оповещения. | Раздел «Управление тихим режимом» -> соответствующая кнопка. | Продолжаются лишние уведомления в нерабочее время/во время инцидента. |
| 9 | Включить принудительно громкий режим | Немедленно вернуть оповещения в активный режим. | Раздел «Управление тихим режимом» -> соответствующая кнопка. | Важные алерты могут быть пропущены. |
| 10 | Вернуть автоматический режим | Вернуться к управлению уведомлениями по расписанию. | Раздел «Управление тихим режимом» -> соответствующая кнопка. | Бот остаётся в ручном режиме дольше нужного, что приводит к ошибкам эксплуатации. |
| 11 | Настройки | Перейти к основным настройкам бота. | Главное меню -> кнопка «Настройки». | Нет точки входа для изменения конфигурации. |
| 12 | Настройки бота | Изменять токен и chat ID (в перспективе: Telegram/TamTam). | Раздел «Настройки» -> «Настройки бота». | Нельзя корректно перенастроить интеграции и каналы доставки. |
| 13 | Временные настройки | Задать «начало/конец тихого режима» и «время сбора данных». | Раздел «Настройки» -> «Временные настройки». | Ломается расписание оповещений и сбор телеметрии в нужные интервалы. |
| 14 | Мониторинг | Настроить «интервал проверки», «макс. время простоя», «таймауты». | Раздел «Настройки» -> «Мониторинг». | Мониторинг работает слишком редко/часто или дает ложные срабатывания. |
| 15 | Аутентификация | Задать параметры доступа SSH/Windows для проверок. | Раздел «Настройки» -> «Аутентификация». | Проверки ресурсов и доступности не смогут выполняться на части серверов. |

###### Нужно ли добавлять автоматические сценарии без участия пользователя?

Да, обязательно. Для API 202020 это отдельный важный блок, потому что автологика создаёт значимую нагрузку, влияет на ошибки и задаёт требования к SLO/timeout.

Рекомендуется добавить после пользовательских сценариев ещё 5–8 системных сценариев:

1. Плановый цикл мониторинга серверов по расписанию.
2. Плановый сбор метрик ресурсов по расписанию.
3. Автоматическое переключение quiet/loud режима по времени.
4. Автоматическая отправка утреннего отчёта по расписанию.
5. Эскалация/повтор уведомления при длительном простое.
6. Деградационный режим при недоступности части downstream.

Мини-карточка для автосценария почти такая же, только вместо «Где в Android» используем поле `Триггер` (cron/таймер/условие).

###### Кто что делает на Шаге 1 (чтобы идти дальше без затыков)

**Что можешь сделать ты (быстро и с максимальной пользой):**

1. Проверь названия пунктов меню «как в интерфейсе» (без перефразирования).
2. Отметь дубли и скрытые зависимости (например, кнопки, которые доступны только после выбора сервера).
3. Добавь 5–8 автосценариев из реального поведения бота (расписание, ретраи, автоуведомления).
4. Для каждого сценария коротко допиши «что критично сломается», если он недоступен.

**Что делаю я:**

1. Нормализую формулировки под контрактный стиль (чтобы удобно перейти к Шагу 2 и Шагу 3).
2. Раскладываю сценарии в P0/P1 и отмечаю рискованные места как `Open questions`.
3. Подготавливаю черновые endpoint draft и error draft для P0.
4. Собираю итоговую таблицу «Scenario -> Priority -> Endpoint -> Errors -> Open questions» для закрытия Дня 1.

---

#### Шаг 2. Приоритизировать без магии (45–60 минут)

Используем только два приоритета:

- `P0` — без этого релиз бессмысленен;
- `P1` — полезно, но можно после первого релиза.

Как принимать решение:

1. По каждому сценарию задай 2 вопроса:
   - это влияет на основной пользовательский путь?
   - это можно сделать без сильного риска по срокам?
2. Проставь `P0/P1`.
3. Проверь баланс: обычно 5–7 сценариев в `P0`, остальные в `P1`.

**Готово, если:** есть короткий список P0, который реально сделать в первом проходе.

---

#### Шаг 3. Для каждого P0 описать контракт «вход/выход/ошибки» (2–3 часа)

Сейчас уже думаем про API, но без реализации.

Для каждого `P0` заполни шаблон:

1. **Вход (Request):**
   - `Метод + endpoint` (например, `GET /v1/profile`);
   - обязательные параметры (`path/query/body`);
   - обязательные заголовки (`Authorization`, `X-Request-ID` и т.д.).
2. **Выход (Response):**
   - только нужные поля для экрана (не тащим «на будущее»);
   - какие поля обязательны, какие nullable;
   - нужна ли пагинация/сортировка.
3. **Ошибки:**
   - бизнес-ошибки (например, «пользователь не найден»);
   - технические (timeout, unavailable, invalid_argument);
   - что именно увидит клиент (`code`, `message`, `request_id`).

**Готово, если:** на каждый P0 есть черновой endpoint и ожидаемое поведение в ошибках.

---

#### Шаг 4. Самопроверка, чтобы не поломать текущего бота (60 минут)

Прогони 4 короткие проверки:

1. **Проверка совместимости:** не меняем существующие endpoint/поля, только описываем новые или явно версионируем (`/v1`).
2. **Проверка минимальности:** нет «лишних» полей, которые не использует Android-экран.
3. **Проверка реалистичности:** для каждого endpoint понятно, из какого downstream берутся данные.
4. **Проверка наблюдаемости:** у всех ошибок есть `request_id`, чтобы потом дебажить инциденты.

Если что-то не проходит — не чинить кодом, а занести в `Open questions`.

**Готово, если:** нет решений, которые ломают текущий рабочий контур бота.

---

#### Шаг 5. Закрыть день артефактом и планом на завтра (30 минут)

Собери финальную таблицу:

- `Scenario`;
- `Priority (P0/P1)`;
- `Endpoint draft`;
- `Downstream draft`;
- `Main errors`;
- `Open questions`;
- `Decision owner`;
- `Due date`.

Внизу добавь блок **«Старт Дня 2»** (3–5 пунктов: что решаем первым).

**Готово, если:** утром следующего дня ты открываешь документ и сразу понимаешь, что делать дальше.

---

#### Мини-чеклист «День 1 выполнен»

- [ ] Есть список сценариев и приоритеты `P0/P1`.
- [ ] Для каждого P0 есть `вход/выход/ошибки`.
- [ ] Все спорные места вынесены в `Open questions`.
- [ ] Нет изменений в runtime-коде текущего бота.
- [ ] Зафиксирован чёткий план старта Дня 2.

**Артефакт дня:** таблица сценариев с приоритетами, черновыми контрактами и списком открытых вопросов.

### День 2 — внешние и внутренние контракты

1. Спроектировать **внешний контракт BFF**:
   - endpoint naming/версионирование (`/v1/...`);
   - единый envelope ошибок (`code`, `message`, `request_id`, `details`);
   - пагинация/фильтрация/сортировка;
   - требования к backward compatibility.
2. Спроектировать **внутренний контракт BFF -> gRPC**:
   - proto messages и rpc;
   - retry semantics (какие вызовы можно безопасно повторять);
   - idempotency ключи для write-операций;
   - mapping бизнес-ошибок в внешний формат BFF.
3. Согласовать с Android + сервисными командами и собрать список расхождений.

**Артефакт дня:** пакет контрактов (OpenAPI/описание endpoint + proto draft + матрица ошибок).

### День 3 — нефункционал, риски и backlog

1. Зафиксировать SLO/SLI:
   - latency: p50/p95/p99 на ключевые endpoint;
   - error rate;
   - доступность BFF.
2. Разложить timeout budget по цепочке:
   - Android -> BFF;
   - BFF -> gRPC сервис #1/#2;
   - общий дедлайн запроса.
3. Определить деградации:
   - fallback ответы;
   - частичное заполнение payload;
   - поведение при timeout одного из downstream.
4. Сформировать backlog на Этап 2:
   - задачи на каркас BFF;
   - приоритетные 2–3 endpoint для вертикального среза;
   - контрактные тесты и проверки observability.

**Артефакт дня:** финальный документ этапа + задачник следующего этапа.

---

## 4) Формат артефактов (чтобы не было бардака)

1. `docs/contracts/external_bff_api.md` — внешние endpoint и примеры ответов.
2. `docs/contracts/internal_grpc_contracts.md` — соответствие endpoint -> rpc.
3. `docs/contracts/error_mapping.md` — карта ошибок (downstream -> BFF).
4. `docs/contracts/slo_timeout_budget.md` — SLO и таймауты.
5. `docs/backlog/stage2_vertical_slice.md` — задачи на следующий этап.

Если форматы уже есть в репозитории, используем существующие шаблоны и просто дополняем.

---

## 5) Definition of Done (DoD) для Этапа 1

Этап считается завершенным, если:

1. Утверждены 5–10 сценариев с приоритетами `P0/P1`.
2. Внешние контракты BFF согласованы с Android командой.
3. Внутренние gRPC контракты согласованы с владельцами сервисов.
4. Есть единый формат ошибок и mapping для всех P0 сценариев.
5. Зафиксированы SLO и timeout budget на P0 сценарии.
6. Сформирован backlog Этапа 2 с оценками и зависимостями.

---

## 6) Основные риски и как их заранее прибить

1. **Риск:** Android просит изменить payload уже после старта реализации.
   - **Митигировать:** раннее согласование примеров JSON и обязательный sign-off от Android.
2. **Риск:** внутренние сервисы не готовы к нужным полям/методам.
   - **Митигировать:** зафиксировать gap-list в конце Дня 2 и назначить владельцев.
3. **Риск:** не укладываемся в latency из-за каскада вызовов.
   - **Митигировать:** ограничить fan-out, ввести timeout budget и деградационный режим.
4. **Риск:** разнобой в кодах ошибок.
   - **Митигировать:** единая таблица error mapping + обязательные контрактные тесты.

---

## 7) Короткий operational checklist на старт Этапа 2

- [ ] У всех P0 endpoint есть согласованный контракт и примеры.
- [ ] У всех P0 сценариев есть mapping в конкретные gRPC вызовы.
- [ ] В error mapping нет «TBD» по критичным кейсам.
- [ ] SLO/timeout budget подписаны техлидом.
- [ ] Backlog вертикального среза содержит владельца и оценку по каждой задаче.

После этого можно безопасно переходить к реализации каркаса BFF и первому e2e срезу.
