# План: проверка и запуск TLS для `api.202020.ru:8443` (BFF + gRPC)

Ниже обновленный план с учетом текущей ситуации: DNS уже настроен, главная затычка — корректный выпуск/подключение сертификата для `api.202020.ru` и проверка, что всё реально работает снаружи.

## 0) Что сделать **перед всеми остальными этапами**: тест сертификата

Цель этого этапа — не «надеяться», а жёстко подтвердить по шагам, что TLS реально рабочий и reverse proxy отдает нужный сертификат на `8443`.

### Чек-лист проверки (по порядку)

1. **Проверить DNS-резолв домена**
   - `api.202020.ru` должен указывать на `91.217.63.94`.
   - Команда:
     ```bash
     dig +short api.202020.ru A
     ```
   - Ожидание: в ответе есть `91.217.63.94`.

2. **Проверить доступность порта 8443 с внешней сети**
   - Команды:
     ```bash
     nc -vz api.202020.ru 8443
     ```
     или
     ```bash
     nmap -p 8443 api.202020.ru
     ```
   - Ожидание: порт открыт (`succeeded` / `open`).

3. **Проверить, что на 8443 отдается именно TLS-сертификат для `api.202020.ru`**
   - Команда:
     ```bash
     openssl s_client -connect api.202020.ru:8443 -servername api.202020.ru -showcerts </dev/null
     ```
   - Что смотрим в выводе:
     - `subject`/`CN` содержит `api.202020.ru` (или SAN включает этот домен).
     - нет критичных ошибок верификации цепочки.

4. **Проверить SAN и срок действия сертификата**
   - Команды:
     ```bash
     openssl s_client -connect api.202020.ru:8443 -servername api.202020.ru </dev/null 2>/dev/null \
       | openssl x509 -noout -subject -issuer -dates -ext subjectAltName
     ```
   - Ожидание:
     - SAN содержит `DNS:api.202020.ru`.
     - `notAfter` в адекватном горизонте (не скоро истекает).

5. **Проверить HTTP-ответ через TLS на 8443**
   - Команда:
     ```bash
     curl -vk https://api.202020.ru:8443/health
     ```
     (или реальный health endpoint BFF)
   - Ожидание:
     - есть успешный TLS handshake;
     - приложение отвечает (200/401/404 — зависит от endpoint, главное что reverse proxy и TLS рабочие).

6. **Проверить, что reverse proxy использует актуальные файлы сертификата**
   - На сервере:
     ```bash
     nginx -t
     systemctl reload nginx
     ```
   - Ожидание: `syntax is ok`, reload без ошибок.

7. **Проверить автопродление (dry-run)**
   - Для certbot:
     ```bash
     certbot renew --dry-run
     ```
   - Для acme.sh:
     ```bash
     acme.sh --renew -d api.202020.ru --dry-run
     ```
   - Ожидание: dry-run успешен, renewal рабочий.

8. **Проверить с Android-стороны (минимум 1 реальный запрос)**
   - Прогнать запрос к `https://api.202020.ru:8443/...` с тестового билда.
   - Убедиться, что нет SSLHandshakeException/CertPathValidatorException.

### Критерий «этап пройден»

Этап считается закрытым только если одновременно выполнено:
- DNS корректно резолвит `api.202020.ru` в `91.217.63.94`.
- `8443` открыт извне.
- Сертификат валиден для `api.202020.ru` и отдается именно на `:8443`.
- `curl` к BFF через TLS проходит.
- dry-run renewal проходит.
- Android тестовый запрос проходит без SSL ошибок.

---

## 1) Обновленный план проекта (после устранения TLS-затыка)

## Этап 0. TLS smoke & валидация контура (сразу сейчас, 0.5-1 день)

- Выполнить полный чек-лист выше.
- Зафиксировать результаты в коротком runbook (`что проверяли / чем / какой вывод`).
- Если есть провал — чинить только TLS/8443/DNS до зеленого статуса.

**Результат:** подтвержденный рабочий HTTPS-контур `api.202020.ru:8443`.

## Этап 1. Проектирование BFF-контрактов (2-3 дня)

- Выбрать 5-10 ключевых Android-сценариев.
- Зафиксировать внешний контракт (REST/gRPC на сценарий).
- Зафиксировать внутренние proto-контракты (BFF -> сервисы).
- Определить SLO (latency/error budget/timeouts).

**Результат:** схема + список контрактов + понятный backlog.

## Этап 2. Каркас BFF и вертикальный срез (3-5 дней)

- Поднять BFF с `/health` и `/ready`.
- Подключить минимум 1 внутренний gRPC сервис.
- Реализовать 2-3 пилотных endpoint.
- Протянуть `request_id` через логи и ответы.

**Результат:** Android -> BFF -> gRPC сервис работает end-to-end.

## Этап 3. Расширение API под Android (1-2 недели)

- Реализовать все необходимые endpoint'ы.
- Добавить BFF-агрегацию payload под экраны.
- Ввести единый формат ошибок.
- Добавить кеш для тяжелых сценариев.

**Результат:** Android-клиент полноценно работает через BFF.

## Этап 4. Надежность и наблюдаемость (3-5 дней)

- Метрики: RPS, p95/p99, 4xx/5xx, timeout.
- Трассировка: OpenTelemetry.
- Алерты на деградации и ошибки renewal сертификата.
- Тест деградации: падение одного внутреннего сервиса.

**Результат:** система наблюдаемая, инциденты быстро детектятся.

## Этап 5. Релиз и стабилизация (3-7 дней)

- Поэтапное включение трафика (canary/проценты).
- План быстрого rollback.
- Пост-релизный мониторинг и донастройка.

**Результат:** стабильный релиз без сюрпризов.

---

## 2) Практический «антипень»: где чаще всего всё ломается

1. **Сертификат выпущен, но Nginx отдает старый**
   - Причина: забыли reload после обновления файлов.
   - Лечение: `nginx -t && systemctl reload nginx`.

2. **Сертификат есть, но не на тот hostname**
   - Причина: SAN не содержит `api.202020.ru`.
   - Лечение: перевыпуск строго на нужный FQDN.

3. **DNS вроде настроен, но цепочка ACME не видит TXT**
   - Причина: задержка распространения, высокий TTL, кэш.
   - Лечение: TTL 60-120, пауза перед проверкой, повтор challenge.

4. **Android ругается, хотя curl ок**
   - Причина: проблемы trust chain/системного времени/сетевых политик.
   - Лечение: проверить fullchain, время на устройстве, network security config.

---

## 3) Мини-чеклист готовности к следующему этапу

Перед стартом разработки фич:

- [ ] `dig` подтверждает IP `91.217.63.94` для `api.202020.ru`.
- [ ] `openssl s_client` подтверждает корректный cert+SAN.
- [ ] `curl -vk https://api.202020.ru:8443/health` доходит до BFF.
- [ ] `renew --dry-run` успешен.
- [ ] Android делает хотя бы 1 успешный HTTPS-запрос.

Если это не зелёное — дальше идти рано, иначе потом будет ебля на каждом релизе из-за TLS.


## 4) Разбор текущей ошибки из консоли (что уже видно)

По логам:
- `dig +short api.202020.ru A` вернул пусто.
- `nc`/`openssl` упали с `No address associated with hostname`.

Это значит, что сейчас блокер №1 — **DNS-резолв имени `api.202020.ru`**, а не Nginx/сертификат.
Пока FQDN не резолвится, проверять TLS бессмысленно: клиент даже не знает, куда коннектиться.

### Что сделать прямо сейчас (быстрый дебаг)

1. Проверить запись у авторитативных NS зоны:
   ```bash
   dig api.202020.ru A +trace
   dig @ns3-l2.nic.ru api.202020.ru A +short
   dig @ns4-l2.nic.ru api.202020.ru A +short
   dig @ns8-l2.nic.ru api.202020.ru A +short
   dig @ns4-cloud.nic.ru api.202020.ru A +short
   dig @ns8-cloud.nic.ru api.202020.ru A +short
   ```
   > Для зоны `202020.ru` авторитативные NS именно эти (из делегирования NIC.ru).
2. Проверить, что запись реально существует в панели DNS и нет опечатки в имени (`api`, не `арi`, не `api.` в другой зоне).
3. Если меняли недавно — подождать распространение и снова проверить через публичные резолверы:
   ```bash
   dig @1.1.1.1 api.202020.ru A +short
   dig @8.8.8.8 api.202020.ru A +short
   ```
4. Временно проверить связность в обход DNS:
   ```bash
   curl -vk --resolve api.202020.ru:8443:91.217.63.94 https://api.202020.ru:8443/health
   ```
   Если так работает — значит проблема точно в DNS.

## 5) Нужно ли пробрасывать 8443 на роутере?

Коротко: **да, если reverse proxy стоит за NAT/роутером**.

- Nginx сам по себе только слушает порт на локальной машине (`listen 8443 ssl;`).
- Чтобы внешний трафик дошел до Nginx за роутером, нужен DNAT/port-forward:
  - `WAN:8443 -> LAN_IP_сервера:8443`.
- Плюс нужен firewall allow на роутере и на самом сервере (UFW/iptables/security group).

Когда проброс **не нужен**:
- если сервер с Nginx имеет **белый публичный IP напрямую** и `api.202020.ru` указывает сразу на этот IP.

### Минимальный набор, что стоит показать для точной проверки

Скинь (можно замазать чувствительные данные):
1. Скрин/текст DNS A-записи для `api.202020.ru`.
2. Конфиг Nginx vhost (блок `server { ... }` с `listen 8443 ssl`, `server_name`, `ssl_certificate`, `ssl_certificate_key`).
3. Правило проброса на роутере (если есть NAT).
4. Вывод команд на сервере:
   ```bash
   ss -lntp | rg 8443
   sudo nginx -t
   sudo ufw status verbose
   ```


## 6) Интерпретация текущих фактов (по вашим логам)

Что уже подтверждено:
- `dig @1.1.1.1` и `dig @8.8.8.8` для `api.202020.ru` возвращают пусто => публичной A-записи фактически нет (или wildcard не опубликован в авторитативной зоне в текущей версии).
- `curl --resolve ... 91.217.63.94:8443` дает `Connection refused` => на целевом IP порт 8443 сейчас не принимает соединение извне.

Вывод без розовых очков:
1. Первая проблема — DNS (FQDN не резолвится).
2. Вторая проблема — сетевой доступ до 8443 (NAT/файрвол/листенер).

Порядок, чтобы это починить без ебли по кругу:
1. На роутере сделать проброс `WAN:8443 -> 192.168.20.X:8443` (IP хоста `sr-web-fe`).
2. Разрешить `8443/tcp` в firewall роутера и на `sr-web-fe` (ufw/iptables).
3. На `sr-web-fe` проверить, что nginx реально слушает:
   ```bash
   ss -lntp | rg 8443
   nginx -t && systemctl reload nginx
   ```
4. Снаружи проверить порт по IP:
   ```bash
   nc -vz 91.217.63.94 8443
   ```
5. Исправить DNS в панели зоны (явно добавить `api.202020.ru A 91.217.63.94`, не надеяться на wildcard).
6. Проверить авторитативные NS и публичные резолверы, что A появилась.
7. После этого проверить TLS:
   ```bash
   openssl s_client -connect api.202020.ru:8443 -servername api.202020.ru -showcerts </dev/null
   curl -vk https://api.202020.ru:8443/health
   ```

## 7) Проверка вашего текущего nginx-конфига

По показанному блоку `server` конфиг в целом ок:
- `listen 8443 ssl http2;` — верно.
- `server_name api.202020.ru;` — верно.
- Сертификат и ключ выделены под `api.202020.ru` — верно.
- `proxy_pass http://192.168.20.2:80;` — норм, если этот backend живой.

Что стоит добавить (не критично, но правильно):
```nginx
ssl_protocols TLSv1.2 TLSv1.3;
```
(если версия OpenSSL/nginx поддерживает TLSv1.3).


## 8) Новый статус после проброса порта: что это значит

По вашим свежим логам:
- `curl --resolve ... 91.217.63.94:8443` теперь успешно коннектится, TLS поднимается, сертификат `CN=api.202020.ru` отдается, `nc -vz 91.217.63.94 8443` = open.
- Но DNS всё еще не резолвит `api.202020.ru` ни через авторитативные NS, ни через 1.1.1.1/8.8.8.8.
- `/health` вернул `404` и HTML от Apache backend — это нормально для проверки транспорта: reverse proxy и TLS уже рабочие, просто такого endpoint на backend нет.

### Важный нюанс, почему wildcard может НЕ сработать

В зоне есть запись `_acme-challenge.api.202020.ru TXT ...`.
Это создает **empty non-terminal** узел `api.202020.ru`, и из-за этого wildcard `*.202020.ru` может не применяться к `api.202020.ru`.

Именно поэтому можно видеть ситуацию:
- wildcard A вроде есть,
- но `api.202020.ru A` возвращает пусто.

### Что сделать, чтобы закрыть DNS окончательно

1. Явно добавить запись:
   ```dns
   api.202020.ru. 3600 IN A 91.217.63.94
   ```
2. Подождать публикацию и проверить:
   ```bash
   dig @ns3-l2.nic.ru api.202020.ru A +short
   dig @ns4-cloud.nic.ru api.202020.ru A +short
   dig @1.1.1.1 api.202020.ru A +short
   dig @8.8.8.8 api.202020.ru A +short
   ```
3. После появления A-записи перейти на финальные проверки:
   ```bash
   openssl s_client -connect api.202020.ru:8443 -servername api.202020.ru -showcerts </dev/null
   curl -vk https://api.202020.ru:8443/
   ```

### Текущее состояние проекта (по факту)

- ✅ NAT/порт 8443: починен.
- ✅ TLS на 8443: починен.
- ⚠️ DNS для `api.202020.ru`: не опубликован (нужно явное A).
- ⚠️ `/health`: отсутствует на backend (это уже отдельная задача приложения, не TLS).
